#[cfg(test)]
mod tests {
    use crate::database::Database;
    use std::collections::HashMap;

    const TEST_BYTES: &[u8] = &[
        0x52, 0x45, 0x44, 0x49, 0x53, 0x30, 0x30, 0x31, 0x31, 0xfa, 0x09, 0x72, 0x65, 0x64, 0x69,
        0x73, 0x2d, 0x76, 0x65, 0x72, 0x05, 0x37, 0x2e, 0x32, 0x2e, 0x34, 0xfa, 0x0a, 0x72, 0x65,
        0x64, 0x69, 0x73, 0x2d, 0x62, 0x69, 0x74, 0x73, 0xc0, 0x40, 0xfa, 0x05, 0x63, 0x74, 0x69,
        0x6d, 0x65, 0xc2, 0x27, 0xcb, 0xb3, 0x65, 0xfa, 0x08, 0x75, 0x73, 0x65, 0x64, 0x2d, 0x6d,
        0x65, 0x6d, 0xc2, 0xa0, 0x86, 0x11, 0x00, 0xfa, 0x08, 0x61, 0x6f, 0x66, 0x2d, 0x62, 0x61,
        0x73, 0x65, 0xc0, 0x00, 0xfe, 0x00, 0xfb, 0x01, 0x00, 0x00, 0x05, 0x6d, 0x79, 0x6b, 0x65,
        0x79, 0x05, 0x6d, 0x79, 0x76, 0x61, 0x6c, 0xff, 0x3d, 0x30, 0xa8, 0x7a, 0xcf, 0x3e, 0x03,
        0x9a,
    ];

    #[test]
    fn test_parse_and_restore_rdb() {
        // Given
        let mut database = Database::new();
        // When
        database.parse_and_restore_rdb(TEST_BYTES).unwrap();
        // Then
        let mut expected_metadata = HashMap::new();
        expected_metadata.insert("version".into(), "11".into());
        expected_metadata.insert("redis-ver".into(), "7.2.4".into());
        expected_metadata.insert("aof-base".into(), "0".into());
        expected_metadata.insert("redis-bits".into(), "64".into());
        expected_metadata.insert("ctime".into(), "1706281767".into());
        expected_metadata.insert("used-mem".into(), "1148576".into());
        assert_eq!(database.metadata, expected_metadata);
        assert_eq!(database.get("mykey".into()).unwrap(), Some("myval".into()));
    }
}
